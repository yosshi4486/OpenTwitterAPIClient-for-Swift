//
// TweetCreateRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct TweetCreateRequest: Codable, JSONEncodable, Hashable {

    public enum ReplySettings: String, Codable, CaseIterable {
        case following = "following"
        case mentionedusers = "mentionedUsers"
    }
    /** Link to take the conversation from the public timeline to a private Direct Message. */
    public var directMessageDeepLink: String?
    /** Exclusive Tweet for super followers. */
    public var forSuperFollowersOnly: Bool? = false
    public var geo: TweetCreateRequestGeo?
    public var media: TweetCreateRequestMedia?
    public var poll: TweetCreateRequestPoll?
    /** Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    public var quoteTweetId: String?
    public var reply: TweetCreateRequestReply?
    /** Settings to indicate who can reply to the Tweet. */
    public var replySettings: ReplySettings?
    /** The content of the Tweet. */
    public var text: String?

    public init(directMessageDeepLink: String? = nil, forSuperFollowersOnly: Bool? = false, geo: TweetCreateRequestGeo? = nil, media: TweetCreateRequestMedia? = nil, poll: TweetCreateRequestPoll? = nil, quoteTweetId: String? = nil, reply: TweetCreateRequestReply? = nil, replySettings: ReplySettings? = nil, text: String? = nil) {
        self.directMessageDeepLink = directMessageDeepLink
        self.forSuperFollowersOnly = forSuperFollowersOnly
        self.geo = geo
        self.media = media
        self.poll = poll
        self.quoteTweetId = quoteTweetId
        self.reply = reply
        self.replySettings = replySettings
        self.text = text
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case directMessageDeepLink = "direct_message_deep_link"
        case forSuperFollowersOnly = "for_super_followers_only"
        case geo
        case media
        case poll
        case quoteTweetId = "quote_tweet_id"
        case reply
        case replySettings = "reply_settings"
        case text
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(directMessageDeepLink, forKey: .directMessageDeepLink)
        try container.encodeIfPresent(forSuperFollowersOnly, forKey: .forSuperFollowersOnly)
        try container.encodeIfPresent(geo, forKey: .geo)
        try container.encodeIfPresent(media, forKey: .media)
        try container.encodeIfPresent(poll, forKey: .poll)
        try container.encodeIfPresent(quoteTweetId, forKey: .quoteTweetId)
        try container.encodeIfPresent(reply, forKey: .reply)
        try container.encodeIfPresent(replySettings, forKey: .replySettings)
        try container.encodeIfPresent(text, forKey: .text)
    }
}

