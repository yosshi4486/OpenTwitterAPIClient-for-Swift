//
// User.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The Twitter User object */
public struct User: Codable {

    /** Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    public var id: String
    /** Creation time of this user. */
    public var createdAt: Date?
    /** The friendly name of this user, as shown on their profile. */
    public var name: String
    /** The Twitter handle (screen name) of this user. */
    public var username: String
    /** Indicates if this user has chosen to protect their Tweets (in other words, if this user's Tweets are private). */
    public var protected: Bool?
    /** Indicate if this user is a verified Twitter User. */
    public var verified: Bool?
    public var withheld: UserWithheld?
    /** The URL to the profile image for this user. */
    public var profileImageUrl: String?
    /** The location specified in the user's profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries. */
    public var location: String?
    /** The URL specified in the user's profile. */
    public var url: String?
    /** The text of this user's profile description (also known as bio), if the user provided one. */
    public var description: String?
    public var entities: UserEntities?
    /** Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers. */
    public var pinnedTweetId: String?
    public var publicMetrics: UserPublicMetrics?

    public init(id: String, createdAt: Date? = nil, name: String, username: String, protected: Bool? = nil, verified: Bool? = nil, withheld: UserWithheld? = nil, profileImageUrl: String? = nil, location: String? = nil, url: String? = nil, description: String? = nil, entities: UserEntities? = nil, pinnedTweetId: String? = nil, publicMetrics: UserPublicMetrics? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.name = name
        self.username = username
        self.protected = protected
        self.verified = verified
        self.withheld = withheld
        self.profileImageUrl = profileImageUrl
        self.location = location
        self.url = url
        self.description = description
        self.entities = entities
        self.pinnedTweetId = pinnedTweetId
        self.publicMetrics = publicMetrics
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case createdAt = "created_at"
        case name
        case username
        case protected
        case verified
        case withheld
        case profileImageUrl = "profile_image_url"
        case location
        case url
        case description
        case entities
        case pinnedTweetId = "pinned_tweet_id"
        case publicMetrics = "public_metrics"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encode(name, forKey: .name)
        try container.encode(username, forKey: .username)
        try container.encodeIfPresent(protected, forKey: .protected)
        try container.encodeIfPresent(verified, forKey: .verified)
        try container.encodeIfPresent(withheld, forKey: .withheld)
        try container.encodeIfPresent(profileImageUrl, forKey: .profileImageUrl)
        try container.encodeIfPresent(location, forKey: .location)
        try container.encodeIfPresent(url, forKey: .url)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(entities, forKey: .entities)
        try container.encodeIfPresent(pinnedTweetId, forKey: .pinnedTweetId)
        try container.encodeIfPresent(publicMetrics, forKey: .publicMetrics)
    }
}

