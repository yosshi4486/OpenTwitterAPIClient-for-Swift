//
// Problem.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807). */
public enum Problem: Codable {
    case typeClientDisconnectedProblem(ClientDisconnectedProblem)
    case typeClientForbiddenProblem(ClientForbiddenProblem)
    case typeConflictProblem(ConflictProblem)
    case typeConnectionExceptionProblem(ConnectionExceptionProblem)
    case typeDisallowedResourceProblem(DisallowedResourceProblem)
    case typeDuplicateRuleProblem(DuplicateRuleProblem)
    case typeFieldUnauthorizedProblem(FieldUnauthorizedProblem)
    case typeGenericProblem(GenericProblem)
    case typeInvalidRequestProblem(InvalidRequestProblem)
    case typeInvalidRuleProblem(InvalidRuleProblem)
    case typeNonCompliantRulesProblem(NonCompliantRulesProblem)
    case typeOperationalDisconnectProblem(OperationalDisconnectProblem)
    case typeResourceNotFoundProblem(ResourceNotFoundProblem)
    case typeResourceUnauthorizedProblem(ResourceUnauthorizedProblem)
    case typeResourceUnavailableProblem(ResourceUnavailableProblem)
    case typeRulesCapProblem(RulesCapProblem)
    case typeUnsupportedAuthenticationProblem(UnsupportedAuthenticationProblem)
    case typeUsageCapExceededProblem(UsageCapExceededProblem)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeClientDisconnectedProblem(let value):
            try container.encode(value)
        case .typeClientForbiddenProblem(let value):
            try container.encode(value)
        case .typeConflictProblem(let value):
            try container.encode(value)
        case .typeConnectionExceptionProblem(let value):
            try container.encode(value)
        case .typeDisallowedResourceProblem(let value):
            try container.encode(value)
        case .typeDuplicateRuleProblem(let value):
            try container.encode(value)
        case .typeFieldUnauthorizedProblem(let value):
            try container.encode(value)
        case .typeGenericProblem(let value):
            try container.encode(value)
        case .typeInvalidRequestProblem(let value):
            try container.encode(value)
        case .typeInvalidRuleProblem(let value):
            try container.encode(value)
        case .typeNonCompliantRulesProblem(let value):
            try container.encode(value)
        case .typeOperationalDisconnectProblem(let value):
            try container.encode(value)
        case .typeResourceNotFoundProblem(let value):
            try container.encode(value)
        case .typeResourceUnauthorizedProblem(let value):
            try container.encode(value)
        case .typeResourceUnavailableProblem(let value):
            try container.encode(value)
        case .typeRulesCapProblem(let value):
            try container.encode(value)
        case .typeUnsupportedAuthenticationProblem(let value):
            try container.encode(value)
        case .typeUsageCapExceededProblem(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(ClientDisconnectedProblem.self) {
            self = .typeClientDisconnectedProblem(value)
        } else if let value = try? container.decode(ClientForbiddenProblem.self) {
            self = .typeClientForbiddenProblem(value)
        } else if let value = try? container.decode(ConflictProblem.self) {
            self = .typeConflictProblem(value)
        } else if let value = try? container.decode(ConnectionExceptionProblem.self) {
            self = .typeConnectionExceptionProblem(value)
        } else if let value = try? container.decode(DisallowedResourceProblem.self) {
            self = .typeDisallowedResourceProblem(value)
        } else if let value = try? container.decode(DuplicateRuleProblem.self) {
            self = .typeDuplicateRuleProblem(value)
        } else if let value = try? container.decode(FieldUnauthorizedProblem.self) {
            self = .typeFieldUnauthorizedProblem(value)
        } else if let value = try? container.decode(GenericProblem.self) {
            self = .typeGenericProblem(value)
        } else if let value = try? container.decode(InvalidRequestProblem.self) {
            self = .typeInvalidRequestProblem(value)
        } else if let value = try? container.decode(InvalidRuleProblem.self) {
            self = .typeInvalidRuleProblem(value)
        } else if let value = try? container.decode(NonCompliantRulesProblem.self) {
            self = .typeNonCompliantRulesProblem(value)
        } else if let value = try? container.decode(OperationalDisconnectProblem.self) {
            self = .typeOperationalDisconnectProblem(value)
        } else if let value = try? container.decode(ResourceNotFoundProblem.self) {
            self = .typeResourceNotFoundProblem(value)
        } else if let value = try? container.decode(ResourceUnauthorizedProblem.self) {
            self = .typeResourceUnauthorizedProblem(value)
        } else if let value = try? container.decode(ResourceUnavailableProblem.self) {
            self = .typeResourceUnavailableProblem(value)
        } else if let value = try? container.decode(RulesCapProblem.self) {
            self = .typeRulesCapProblem(value)
        } else if let value = try? container.decode(UnsupportedAuthenticationProblem.self) {
            self = .typeUnsupportedAuthenticationProblem(value)
        } else if let value = try? container.decode(UsageCapExceededProblem.self) {
            self = .typeUsageCapExceededProblem(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of Problem"))
        }
    }
}

